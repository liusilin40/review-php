<?php
/**
* @file variable.php
* @brief 本文件是对“php手册-语言参考-变量”部分的实践与理解
* @author 640
* @version 1.0
* @date 2017-06-28
 */

/**
 * 基础
 * 命名规则：PHP 中的变量用一个美元符号后面跟变量名来表示。变量名是区分大小写的。 
 * 			 变量名：'[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*'
 * 全局命名空间：
 * 			以下代码结构会进入全局命名空间：
 * 				1. functions（函数）
 * 				2. classes（类）
 * 				3. interfaces（接口）
 * 				4. constants（常量，并非类常量）
 * 				5. 在函数/方法之外定义的变量
 *
 * 赋值：
 * 		1. 传值赋值
 * 		2. 引用赋值
 *
 * 变量初始化：
 * 		虽然在 PHP 中并不需要初始化变量，但对变量进行初始化是个好习惯。
 * 		未初始化的变量具有其类型的默认值：（未初始化的变量默认值为NULL，当转换为指定类型后，默认值才是下面的值）
 * 			类型		默认值
 * 			bool		false
 * 			整型		0
 * 			float		0
 * 			string		''
 * 			array		[]
 */

/**
 * 变量的范围
 * 变量的范围即它定义的上下文背景（也就是它的生效范围）
 * 大部分的 PHP 变量只有一个单独的范围。这个单独的范围跨度同样包含了 include 和 require 引入的文件。
 * 在用户自定义函数中，一个局部函数范围将被引入。任何用于函数内部的变量按缺省情况将被限制在局部函数范围内。
 *
 * 为了在函数中使用全局变量，两种方法：
 * 	1. global关键字
 * 	2. $GLOBALS超全局变量
 *
 * 为了在程序离开局部函数域后，特定的值并不丢失。可以使用静态变量static。静态变量仅在局部函数域中存在，但当程序执行离开此作用域时，其值并不丢失。
 * 静态申明是在编译时解析的。所以，如果在声明中用表达式的结果对其赋值会导致解析错误。(经检验，这里所说的表达式只限于含有变量的表达式和函数表达式。对于常量表达式如1+1，
 * 不会报解析错误。)
 *
 * 全局和静态变量的引用
 * 			没看懂。详细见原文。
 */
$a = 1;
include 'b.inc';			//这里变量 $a 将会在包含文件 b.inc 中生效。

function foo(){
	static $int = 0;          // correct
	static $int = 1+2;        // correct 
	static $int = sqrt(121);  // wrong  (as it is an expression too)

	$int++;
	echo $int;
}

/**
 * 可变变量
 * 即用变量来表述变量名。
 * 如：$hello = 'Ni hao';
 * 	   $name = 'hello';
 * 	   echo $$name;		//输出：Ni hao
 *
 * 有时候使用可变变量名是很方便的。就是说，一个变量的变量名可以动态的设置和使用。一个可变变量获取了一个普通变量的值作为这个可变变量的变量名
 *
 * 要将可变变量用于数组，必须解决一个模棱两可的问题。这就是当写下 $$a[1] 时，解析器需要知道是想要 $a[1] 作为一个变量呢，还是想要 $$a 作为一
 * 个变量并取出该变量中索引为 [1] 的值。解决此问题的语法是，对第一种情况用 ${$a[1]}，对第二种情况用 ${$a}[1]。
 * 类的属性也可以通过可变属性名来访问。可变属性名将在该调用所处的范围内被解析。例如，对于 $foo->$bar 表达式，则会在本地范围来解析 $bar 并且
 * 其值将被用于 $foo 的属性名。对于 $bar 是数组单元时也是一样。
 * 也可使用花括号来给属性名清晰定界。最有用是在属性位于数组中，或者属性名包含有多个部分或者属性名包含有非法字符时（例如来自 json_decode() 或 SimpleXML）。 
 *
 * 注意，在 PHP 的函数和类的方法中，超全局变量不能用作可变变量。$this 变量也是一个特殊变量，不能被动态引用。 
 */
class foo {
	var $bar = 'I am bar.';
	var $arr = array('I am A.', 'I am B.', 'I am C.');
	var $r   = 'I am r.';
}

$foo = new foo();
$bar = 'bar';
$baz = array('foo', 'bar', 'baz', 'quux');
echo $foo->$bar . "\n";				//I am bar.
echo $foo->$baz[1] . "\n";				//I am bar.

$start = 'b';
$end   = 'ar';
echo $foo->{$start . $end} . "\n";				//I am bar.

$arr = 'arr';
echo $foo->$arr[1] . "\n";				//I am r.
echo $foo->{$arr}[1] . "\n";			//I am B.
