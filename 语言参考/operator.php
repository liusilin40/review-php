<?php
/**
* @file operator.php
* @brief 本文件是对“php手册-语言参考-运算符”部分的实践与理解
* @author 640
* @version 1.0
* @date 2017-06-29
 */

/**
 * 算术运算符
 * -$a      取反
 * 加、减、乘、除、取模
 * $a**$b   求幂 php5.6引入
 *
 * 除法运算符总是返回浮点数。只有在下列情况例外：两个操作数都是整数（或字符串转换成的整数）并且正好能整除，这时它返回一
 * 个整数。      
 *
 * 取模运算符的操作数在运算之前都会转换成整数（除去小数部分）。
 * 取模运算符 % 的结果和被除数的符号（正负号）相同。即 $a % $b 的结果和 $a 的符号相同。
 */
echo 4.2%4;     //1
echo (-5 % 3)."\n";          // prints -2
echo (-5 % -3)."\n";         // prints -2
echo 2**3;          // 8 .仅php5.6以后有效

/**
 * 赋值运算符
 * 略
 */

/**
 * 位运算符
 * &    与
 * |    或
 * ~    取反
 * ^    异或
 * >>   右移
 * <<   左移
 *
 *  位移在PHP中是数学运算。向任何方向移出去的位都被丢弃。左移时右侧以零填充，符号位被移走意味着正负号不被保留。右移时左
 *  侧以符号位填充，意味着正负号被保留。 
 */

/**
 * 比较运算符
 * 略
 */

/**
 * 错误控制运算符
 * @
 * 当将其放置在一个 PHP 表达式之前，该表达式可能产生的任何错误信息都被忽略掉。 
 *
 * 如果用 set_error_handler() 设定了自定义的错误处理函数，仍然会被调用，但是此错误处理函数可以（并且也应该）调用 
 * error_reporting()，而该函数在出错语句前有 @ 时将返回 0。 
 *
 * 如果激活了 track_errors 特性，表达式所产生的任何错误信息都被存放在变量 $php_errormsg 
 * 中。此变量在每次出错时都会被覆盖，所以如果想用它的话就要尽早检查。 
 */
$my_file = @file ('non_existent_file') or
        die ("Failed opening file: error was '$php_errormsg'");

// this works for any expression, not just functions:
$value = @$cache[$key];
// will not issue a notice if the index $key doesn't exist.

/**
 * 执行运算符
 * ``
 * PHP 支持一个执行运算符：反引号（``）。注意这不是单引号！PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出
 * 信息返回（即，可以赋给一个变量而不是简单地丢弃到标准输出）。使用反引号运算符“`”的效果与函数shell_exec() 相同。 
 *
 * 注意：
 *      1. 反引号运算符在激活了安全模式或者关闭了 shell_exec() 时是无效的。 
 *      2. 与其它某些语言不同，反引号不能在双引号字符串中使用。 
 */
$output = `ls -al`;
echo "<pre>$output</pre>";

/**
 * 递增/递减运算符
 * ++$a 、--$a、$a++、$a--
 *
 * 不同的数据类型进行递增/递减运算。
 * bool			递增/递减不影响布尔值。（不要误解为bool自增就是转换为整型再做自增运算。这是错误的）
 * int、float		自加1或者自减1
 * string		在处理字符变量的算数运算时，PHP 沿袭了 Perl 的习惯，而非 C 的。(所谓的Perl习惯指： $a = 'Z'; $a++; 
 * 				将把 $a 变成'AA'。而在C习惯中，a = 'Z'; a++; 将把 a 变成 '['（'Z' 的 ASCII 值是 90，'[' 的 ASCII 值
 * 				是 91）。另外，字符变量只能递增，不能递减，并且只支持存字母a-z和A-Z,递增/递减其他字符变量则无效，原
 * 				字符不会有变化。)
 */
$a = true;
$a++;
var_dump($a);		//bool(true)

$a = 1.2;
$a++;
echo $a;		// 2.2

$a = 'abc';
var_dump(++$a);		//string(3) "abd"
$a = 'zzz';
var_dump(++$a);		//string(4) "aaaa"
$a='12zz';
echo ++$a;			//13aa
$a='12zz*';
echo ++$a;			//12zz*
$a='19zz';
echo ++$a;			//20aa
$a='1*9zz';
echo ++$a;			//1*0aa

/**
 * 逻辑运算符 
 * and  or  xor !   &&  ||
 *
 * 注意与位运算符的差异
 */

/**
 * 字符串运算符
 * . .=
 */

/**
 * 数组运算符
 * 例子     名称    结果
 * $a + $b  联合    $a 和 $b 的联合。
 * $a == $b     相等    如果 $a 和 $b 具有相同的键／值对则为 TRUE。
 * $a === $b    全等    如果 $a 和 $b 具有相同的键／值对并且顺序和类型都相同则为 TRUE。
 * $a != $b     不等    如果 $a 不等于 $b 则为 TRUE。
 * $a <> $b     不等    如果 $a 不等于 $b 则为 TRUE。
 * $a !== $b    不全等  如果 $a 不全等于 $b 则为 TRUE。
 *
 * + 运算符把右边的数组元素附加到左边的数组后面，两个数组中都有的键名，则只用左边数组中的，右边的被忽略。 
 */

/**
 * 类型运算符
 *
 *  1. instanceof 用于确定一个 PHP 变量是否属于某一类 class 的实例
 *  2. instanceof　也可用来确定一个变量是不是继承自某一父类的子类的实例
 *  3. instanceof也可用于确定一个变量是不是实现了某个接口的对象的实例
 *  
 *  注意的点:
 *      1. 虽然 instanceof 通常直接与类名一起使用，但也可以使用对象或字符串变量
 *      2. 如果被检测的变量不是对象，instanceof 并不发出任何错误信息而是返回 FALSE。不允许用来检测常量。 
 *      3. 在 PHP 5.1.0 之前，如果要检查的类名称不存在，instanceof 会调用__autoload()。另外，如果该类没有被装载则会产生
 *      一个致命错误。可以通过使用动态类引用或用一个包含类名的字符串变量来避开这种问题.(没看懂)
 */

